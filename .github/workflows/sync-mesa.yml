name: Mirror GitLab -> GitHub (mesa)

on:
  schedule:
    - cron: "0 * * * *"
  workflow_dispatch:
    inputs:
      mode:
        description: "同步模式：heads-tags=只同步分支+tag（更稳）；mirror=完全镜像（会删除远端多余 refs）"
        type: choice
        options: [heads-tags, mirror]
        default: heads-tags
      source_url:
        description: "GitLab 源仓库地址"
        required: true
        default: "https://gitlab.freedesktop.org/mesa/mesa.git"
      target_repo:
        description: "GitHub 目标仓库（owner/name）"
        required: true
        default: "geezhu/mesa"

concurrency:
  group: mirror-mesa
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      SOURCE_URL: ${{ github.event.inputs.source_url || 'https://gitlab.freedesktop.org/mesa/mesa.git' }}
      TARGET_REPO: ${{ github.event.inputs.target_repo || 'geezhu/mesa' }}
      MODE: ${{ github.event.inputs.mode || 'heads-tags' }}
      # 首次 seed 分块大小：越大越快但越容易超限；mesa 这种建议 500~2000 之间试
      SEED_STEP: "1000"

    steps:
      - name: Clone source repo (mirror)
        run: |
          set -euo pipefail
          rm -rf /tmp/src.git
          git clone --mirror "${SOURCE_URL}" /tmp/src.git

      - name: Add target remote (authenticated)
        env:
          TARGET_REPO_PAT: ${{ secrets.TARGET_REPO_PAT }}
        run: |
          set -euo pipefail
          test -n "${TARGET_REPO_PAT}" || (echo "Missing secret TARGET_REPO_PAT" && exit 1)

          cd /tmp/src.git
          git remote add target "https://x-access-token:${TARGET_REPO_PAT}@github.com/${TARGET_REPO}.git"
          git config --local core.askPass true

      - name: Push to target repo (staged)
        env:
          TARGET_REPO_PAT: ${{ secrets.TARGET_REPO_PAT }}
        run: |
          set -euo pipefail
          cd /tmp/src.git

          retry() {
            # retry <cmd...>
            for n in 1 2 3; do
              "$@" && return 0
              echo "Command failed (attempt $n): $*"
              sleep $((n*20))
            done
            return 1
          }

          # 获取源仓库默认分支（不依赖 remote show 文本输出）
          DEFAULT_REF="$(git ls-remote --symref origin HEAD | awk '/^ref:/ {print $2}' | head -n1)"
          DEFAULT_BRANCH="${DEFAULT_REF#refs/heads/}"
          if [ -z "${DEFAULT_BRANCH}" ] || [ "${DEFAULT_BRANCH}" = "${DEFAULT_REF}" ]; then
            echo "Failed to detect default branch from origin HEAD"
            exit 1
          fi
          echo "Default branch detected: ${DEFAULT_BRANCH}"

          # 判断目标仓库是否“空”（没有任何 heads）
          if ! git ls-remote --heads target | grep -q "refs/heads/"; then
            echo "Target repo appears empty -> seeding ${DEFAULT_BRANCH} in chunks to avoid huge single push."

            STEP="${SEED_STEP}"
            if ! [[ "${STEP}" =~ ^[0-9]+$ ]] || [ "${STEP}" -lt 100 ]; then
              STEP=1000
            fi

            # 取默认分支提交列表（从旧到新）
            mapfile -t COMMITS < <(git rev-list --reverse "refs/heads/${DEFAULT_BRANCH}")
            total="${#COMMITS[@]}"
            echo "Total commits on ${DEFAULT_BRANCH}: ${total}"

            if [ "${total}" -eq 0 ]; then
              echo "No commits found on ${DEFAULT_BRANCH}"
              exit 1
            fi

            i="${STEP}"
            while [ "${i}" -lt "${total}" ]; do
              sha="${COMMITS[$((i-1))]}"
              echo "Seeding ${DEFAULT_BRANCH}: commit ${i}/${total} -> ${sha} (STEP=${STEP})"

              if retry git push target "+${sha}:refs/heads/${DEFAULT_BRANCH}"; then
                i=$((i+STEP))
              else
                STEP=$((STEP/2))
                if [ "${STEP}" -lt 100 ]; then
                  echo "Seeding keeps failing even with small STEP; abort."
                  exit 1
                fi
                echo "Push failed; reducing STEP to ${STEP} and retrying..."
              fi
            done

            echo "Final push of ${DEFAULT_BRANCH} tip"
            retry git push target "+refs/heads/${DEFAULT_BRANCH}:refs/heads/${DEFAULT_BRANCH}"
          else
            echo "Target repo already has heads -> skip seeding."
          fi

          if [ "${MODE}" = "mirror" ]; then
            echo "Mode: mirror (overwrite all refs)."
            # 经过 seed 后，一般会变成“推 refs 变化为主”，更不容易触发超大 pack
            retry git push --mirror target
            exit 0
          fi

          echo "Mode: heads-tags (push branches one-by-one, then tags)."

          # 逐分支推送（比一次性 refs/heads/* 更稳）
          while IFS= read -r b; do
            [ -z "$b" ] && continue
            echo "Pushing branch: $b"
            retry git push target "+refs/heads/$b:refs/heads/$b"
          done < <(git for-each-ref --format='%(refname:short)' refs/heads)

          echo "Pushing tags in batches (auto-skip fsck-bad tags)..."

          mapfile -t TAGS < <(git for-each-ref --sort=creatordate --format='%(refname:short)' refs/tags)
          TOTAL="${#TAGS[@]}"
          echo "Total tags: ${TOTAL}"
          
          BATCH=1
          SKIPPED_FILE="${GITHUB_WORKSPACE:-/tmp}/skipped_tags.txt"
          : > "$SKIPPED_FILE"
          
          push_batch() {
            local start="$1"
            local count="$2"
            local errfile
            errfile="$(mktemp)"
          
            local refspecs=()
            for ((j=0; j<count; j++)); do
              local t="${TAGS[$((start+j))]}"
              [ -z "$t" ] && continue
              refspecs+=("+refs/tags/${t}:refs/tags/${t}")
            done
          
            echo "Pushing tag batch: ${start}..$((start+count-1)) (count=${#refspecs[@]})"
            if retry git push target "${refspecs[@]}" 2>"$errfile"; then
              rm -f "$errfile"
              return 0
            fi
          
            # 把错误输出回显一下，便于 Actions 日志里定位
            echo "Tag push failed stderr:"
            sed -n '1,200p' "$errfile"
          
            # 如果是单个 tag 且命中 fsck 类错误 -> 跳过
            if [ "$count" -eq 1 ] && grep -Eq "missingSpaceBeforeDate|fsck error|index-pack failed|remote unpack failed" "$errfile"; then
              local bad_tag="${TAGS[$start]}"
              echo "SKIP tag due to invalid objects: ${bad_tag}"
              echo "${bad_tag}" >> "$SKIPPED_FILE"
              rm -f "$errfile"
              return 2   # 表示“跳过成功”
            fi
          
            rm -f "$errfile"
            return 1
          }
          
          i=0
          while [ "$i" -lt "$TOTAL" ]; do
            n="$BATCH"
            if [ $((i+n)) -gt "$TOTAL" ]; then n=$((TOTAL-i)); fi
          
            if push_batch "$i" "$n"; then
              i=$((i+n))
              continue
            fi
          
            rc=$?
            if [ "$rc" -eq 2 ]; then
              # 跳过了一个坏 tag
              i=$((i+1))
              continue
            fi
          
            # 批次失败且不是“可跳过单 tag” -> 缩小批次重试
            if [ "$n" -gt 1 ]; then
              BATCH=$((BATCH/2))
              [ "$BATCH" -lt 1 ] && BATCH=1
              echo "Reducing tag batch size to ${BATCH} and retrying..."
              continue
            fi
          
            # 单 tag 失败但不是 fsck 类错误：当成真实异常
            echo "Single tag push failed for ${TAGS[$i]} with non-fsck error; abort."
            exit 1
          done
          
          if [ -s "$SKIPPED_FILE" ]; then
            echo "Skipped tags (invalid objects; cannot be pushed to GitHub):"
            cat "$SKIPPED_FILE"
          fi



      - name: Cleanup
        if: always()
        run: |
          rm -rf /tmp/src.git
