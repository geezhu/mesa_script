name: Mirror GitLab -> GitHub (mesa)

on:
  schedule:
    - cron: "17 3 * * *" #daily update ,trigger when 3:17 UTC to avoid hotspot
  workflow_dispatch:
    inputs:
      mode:
        description: "同步模式：heads-tags=只同步分支+tag（更稳）；mirror=完全镜像（会删除远端多余 refs）"
        type: choice
        options: [heads-tags, mirror]
        default: heads-tags
      source_url:
        description: "GitLab 源仓库地址"
        required: true
        default: "https://gitlab.freedesktop.org/mesa/mesa.git"
      target_repo:
        description: "GitHub 目标仓库（owner/name）"
        required: true
        default: "geezhu/mesa"

concurrency:
  group: mirror-mesa
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      SOURCE_URL: ${{ github.event.inputs.source_url || 'https://gitlab.freedesktop.org/mesa/mesa.git' }}
      TARGET_REPO: ${{ github.event.inputs.target_repo || 'geezhu/mesa' }}
      MODE: ${{ github.event.inputs.mode || 'heads-tags' }}
      SEED_STEP: "1000"

    steps:
      # 关键新增：把“控制仓库”检出到 GITHUB_WORKSPACE，才能读取 bad_tag_objects.txt
      - name: Checkout control repo
        uses: actions/checkout@v4

      - name: Clone source repo (mirror)
        run: |
          set -euo pipefail
          rm -rf /tmp/src.git
          git clone --mirror "${SOURCE_URL}" /tmp/src.git

      - name: Add target remote (authenticated)
        env:
          TARGET_REPO_PAT: ${{ secrets.TARGET_REPO_PAT }}
        run: |
          set -euo pipefail
          test -n "${TARGET_REPO_PAT}" || (echo "Missing secret TARGET_REPO_PAT" && exit 1)

          cd /tmp/src.git
          git remote add target "https://x-access-token:${TARGET_REPO_PAT}@github.com/${TARGET_REPO}.git"
          git config --local core.askPass true

      - name: Push to target repo (staged)
        env:
          TARGET_REPO_PAT: ${{ secrets.TARGET_REPO_PAT }}
        run: |
          set -euo pipefail
          cd /tmp/src.git

          retry() {
            for n in 1 2 3; do
              "$@" && return 0
              echo "Command failed (attempt $n): $*"
              sleep $((n*20))
            done
            return 1
          }

          # 获取源仓库默认分支
          DEFAULT_REF="$(git ls-remote --symref origin HEAD | awk '/^ref:/ {print $2}' | head -n1)"
          DEFAULT_BRANCH="${DEFAULT_REF#refs/heads/}"
          if [ -z "${DEFAULT_BRANCH}" ] || [ "${DEFAULT_BRANCH}" = "${DEFAULT_REF}" ]; then
            echo "Failed to detect default branch from origin HEAD"
            exit 1
          fi
          echo "Default branch detected: ${DEFAULT_BRANCH}"

          # 判断目标仓库是否“空”（没有任何 heads）
          if ! git ls-remote --heads target | grep -q "refs/heads/"; then
            echo "Target repo appears empty -> seeding ${DEFAULT_BRANCH} in chunks to avoid huge single push."

            STEP="${SEED_STEP}"
            if ! [[ "${STEP}" =~ ^[0-9]+$ ]] || [ "${STEP}" -lt 100 ]; then
              STEP=1000
            fi

            mapfile -t COMMITS < <(git rev-list --reverse "refs/heads/${DEFAULT_BRANCH}")
            total="${#COMMITS[@]}"
            echo "Total commits on ${DEFAULT_BRANCH}: ${total}"

            if [ "${total}" -eq 0 ]; then
              echo "No commits found on ${DEFAULT_BRANCH}"
              exit 1
            fi

            i="${STEP}"
            while [ "${i}" -lt "${total}" ]; do
              sha="${COMMITS[$((i-1))]}"
              echo "Seeding ${DEFAULT_BRANCH}: commit ${i}/${total} -> ${sha} (STEP=${STEP})"

              if retry git push target "+${sha}:refs/heads/${DEFAULT_BRANCH}"; then
                i=$((i+STEP))
              else
                STEP=$((STEP/2))
                if [ "${STEP}" -lt 100 ]; then
                  echo "Seeding keeps failing even with small STEP; abort."
                  exit 1
                fi
                echo "Push failed; reducing STEP to ${STEP} and retrying..."
              fi
            done

            echo "Final push of ${DEFAULT_BRANCH} tip"
            retry git push target "+refs/heads/${DEFAULT_BRANCH}:refs/heads/${DEFAULT_BRANCH}"
          else
            echo "Target repo already has heads -> skip seeding."
          fi

          # 如果 mirror 模式：仍然会把坏 tag object 一起推过去而失败（GitHub fsck 会拒绝）
          # 所以：mirror 模式下也先做一次“坏 tag 降级”为 lightweight（否则 mirror 可能失败）
          echo "Sanitizing known-bad annotated tags (convert to lightweight if listed)..."

          LIST_FILE="${GITHUB_WORKSPACE}/bad_tag_objects.txt"
          if [ -f "$LIST_FILE" ]; then
            # 建映射：tag_object_sha -> tag_name（只保留 annotated tag：objecttype==tag）
            git for-each-ref refs/tags --format='%(objectname) %(objecttype) %(refname:short)' \
              | awk '$2=="tag"{print $1, $3}' > /tmp/tagobj_to_name.txt
          
            while read -r tagobj; do
              [ -z "$tagobj" ] && continue
              [[ "$tagobj" =~ ^# ]] && continue
          
              tag="$(awk -v s="$tagobj" '$1==s {print $2; exit}' /tmp/tagobj_to_name.txt || true)"
              if [ -z "$tag" ]; then
                echo "WARN: cannot map bad tag object $tagobj to a tag name; skip"
                continue
              fi
          
              # 从 tag object 里提取其指向的对象（通常是 commit）
              target="$(git cat-file -p "$tagobj" 2>/dev/null | awk '/^object /{print $2; exit}')"
              if [ -z "$target" ]; then
                echo "WARN: cannot read target object from tag object $tagobj (tag=$tag); skip"
                continue
              fi
          
              echo "Convert annotated->lightweight: $tag (bad tagobj $tagobj) => $target"
          
              # 直接更新 refs：把 refs/tags/<tag> 指向 target（lightweight tag）
              git update-ref "refs/tags/$tag" "$target"
          
              # 可选：确认现在 refs/tags/<tag> 的类型（应为 commit/tree/blob，而非 tag）
              echo "  type now: $(git cat-file -t "refs/tags/$tag")"
            done < "$LIST_FILE"
          else
            echo "No bad_tag_objects.txt found in control repo; skip sanitizing."
          fi

          if [ "${MODE}" = "mirror" ]; then
            echo "Mode: mirror (overwrite all refs)."
            retry git push --mirror target
            exit 0
          fi

          echo "Mode: heads-tags (push branches one-by-one, then tags)."

          while IFS= read -r b; do
            [ -z "$b" ] && continue
            echo "Pushing branch: $b"
            retry git push target "+refs/heads/$b:refs/heads/$b"
          done < <(git for-each-ref --format='%(refname:short)' refs/heads)
          
          echo "Pushing tags in batches..."
          
          # 每批推多少个 tag（可按情况调小：20/10 更稳）
          BATCH=2
          
          # 获取 tag 列表（按创建时间排序更平滑，也可以改成 --sort=refname）
          mapfile -t TAGS < <(git for-each-ref --sort=creatordate --format='%(refname:short)' refs/tags)
          TOTAL="${#TAGS[@]}"
          echo "Total tags: ${TOTAL}"
          
          push_tag_batch() {
            local start="$1"
            local count="$2"
          
            local refspecs=()
            for ((j=0; j<count; j++)); do
              local t="${TAGS[$((start+j))]}"
              [ -z "$t" ] && continue
              refspecs+=("+refs/tags/${t}:refs/tags/${t}")
            done
          
            echo "Pushing tags batch: ${start}..$((start+count-1)) (count=${#refspecs[@]})"
            retry git push target "${refspecs[@]}"
          }
          
          i=0
          while [ "$i" -lt "$TOTAL" ]; do
            n="$BATCH"
            if [ $((i+n)) -gt "$TOTAL" ]; then n=$((TOTAL-i)); fi
          
            if push_tag_batch "$i" "$n"; then
              i=$((i+n))
              continue
            fi
          
            # 批次失败：缩小批次重试（常见原因：一次更新 refs 过多 / pack 过大 / 500 抖动）
            if [ "$n" -gt 1 ]; then
              BATCH=$((BATCH/2))
              if [ "$BATCH" -lt 1 ]; then BATCH=1; fi
              echo "Batch failed; reducing tag batch size to ${BATCH} and retrying..."
              continue
            fi
          
            echo "Single tag push failed for tag: ${TAGS[$i]} ; abort."
            exit 1
          done


      - name: Cleanup
        if: always()
        run: |
          rm -rf /tmp/src.git
